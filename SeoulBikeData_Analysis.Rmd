---
bibliography: [references.bib]
nocite: '@*'
csl: 'apa.csl'
output:
  pdf_document:
    includes:
      before_body: title-page.sty
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
library("readxl")
library("ggplot2")
```

\newpage
\textbf{\LARGE Abstract}

\newpage

\newpage
\textbf{\LARGE Introduction}

In the past decade, the usage of public rental bikes has increased in various 
urban cities. In cities, rental bikes have become a crucial part of transportation
because of many reasons. They provide free or affordable access to transportation
for short-distance trips instead of requiring a private vehicle and help reduce 
congestion, noise and air pollution in a city (Winters, 2020). Bike Sharing systems
are now rapidly growing across the world at nearly 2000 various operating programs
in total as of May 2021 (Yu et al., 2021). The demand for these systems is growing
at 14.3% compounded annually from 2017 to 2025 (Cooper, 2019). 
 
There are various public bike rental systems across the world, like in the city 
of Toronto where they have approximately 6,850 bikes and its users have completed
2.9 million trips as of 2020 (Bike Share Toronto, 2021). In New York City there 
are "... nearly eight hundred thousand (773,000) ride a bicycle regularly" and 
have completed over 7 million rides as of September 2021 with a 26% growth in 
daily cycling between 2014 to 2019 (New York City DOT, 2021). One of the biggest
bike-sharing systems is found in China at Hangzhou and Wuhan where their residents
have access to 90,000 and 70,000 bicycles respectively 
(Borowska-Stefańska et al., 2021). 
 
Like many other cities within the world, the city of Seoul in South Korea has 
also founded a bike-sharing system called _Ttareungyi_ or Seoul Public Bike 
started in 2015. It was started to " resolve issues of traffic congestion, air 
pollution, and high oil prices in Seoul, and to build a healthier society while 
enhancing the quality of life for Seoul citizens" (Seoul Metropolitan Government,
2015). As of March 20, 2018, it has exceeded 620,000 memberships with 38% of the 
users using the bikes during rush hour (Seoul Metropolitan Government, 2018). Due
to the high usage of bikes in cities effective management of bike-sharing systems 
must be developed to ensure the general public can access the service when required.
 
The following data set from the Seoul Public Bike initiative provides various 
information like the number of bikes rented, temperature, humidity, wind speed, 
visibility, solar radiation, snowfall and more. This can be used to see how 
weather affects the number of bikes rented per hour and makes a predictive model
for future uses from the given data from December 1st, 2017 to December 1st, 2018. 
This is a very important question to consider since an online survey conducted 
within the geographical region of Asia in 2016 identified,  climate as an "... 
important physical barrier with 25% of respondents strongly agreeing that it 
constrains them physically, particularly warm or warmth and high precipitation 
levels."(Mateo-Babiano et al., 2017) among other reasons like infrastructure 
issues and others.

\newpage
\textbf{Data Preprocessing}

In this stage we are analyzing the data to verify that there are no missing values
in any of the columns, change the format of certain variables to make it easier 
to make visualization from the data.

```{r}
myData = read.csv(file='SeoulBikeData.csv', check.names = F)
```

```{r echo=FALSE}
knitr::kable(x=colnames(myData), format="simple", col.names = "Column Names")
```

From above, we can see that the column names are quite messy and can make it difficult
to use it later. So we will change the value of the columns to make it better.

```{r}
colnames(myData) = c("Date", "RentedBikeCount", "Hour", "Temperature", "Humidity",
                     "Windspeed", "Visibility", "DewPointTemp", "SolarRadiation",
                     "Rainfall", "Snowfall", "Seasons", "Holiday", "FunctioningDay")
```

Now, we check if any of the columns of the data has any null values or corrupted 
values. We use the R built-in function is.na() which will return a vector containing
TRUE or FALSE based on the fact that it is null or not. We then use the any() to 
find out if any of the values is TRUE.

```{r}
checkNullValues = sapply(colnames(myData), FUN = function(col.name) 
                                                  any(is.na(myData[,col.name])))
```

\newpage

```{r echo=FALSE}
knitr::kable(checkNullValues, format="simple", col.names = "Is Null")
rm(checkNullValues)
```

Since for each columns the output is FALSE, therefore all the columns of the 
data does not contain null or corrupted values.

Looking at the date we see a variable called _FunctioningDay_ which is there to
indicate if the if the bike-sharing system is available or not and if we observe 
the amount of rented bikes we see that is 0 for all `r length(myData$Date)` days. 
Since here we are trying to predict how many bikes will be rented when the system
is open. For this reason we can remove these observations and drop that variable
since it will always will be YES.

```{r}
myData = myData[myData$FunctioningDay=="Yes",]
myData = within.data.frame(myData, rm(FunctioningDay))
```

Looking at the data, there is variable called _Date_ which records the Date when
a bikes are rented. We can formatted the values to make use a built-in date function

```{r}
myData$Date = as.Date(myData$Date, format = "%d/%m/%Y")
```

\newpage

\textbf{Exploratory Data Analysis}

# RentedBikeCount (Y)

The number of bikes rented per hour.
```{r echo=FALSE}
summary(myData$RentedBikeCount)
hist(myData$RentedBikeCount)
```

# Hours (X1: h0-h22)

Categorical variable corresponding to what hour of the day it is. Value range from 0 to 23. Base category will be set to hour 23.
```{r}
Hours = unique(myData$Hour)
meanBikeRentalPerHour = rep(0, length(Hours))
for (idx in seq(length(Hours))){
  meanBikeRentalPerHour[idx] = mean(myData[myData$Hour == Hours[idx], "RentedBikeCount"])
}
ggplot(data=as.data.frame(meanBikeRentalPerHour)) +
  geom_col(aes(x=Hours, y=meanBikeRentalPerHour, fill=Hours)) + 
  scale_fill_gradient(low="grey",high="black") +
  labs(x = "Hours", y = "Mean Rented Bikes Count")
rm(Hours, meanBikeRentalPerHour, idx)
```

# Temperature (X2)

Temperature measured in degree celsius (℃) at hour of observation.
```{r}
summary(myData$Temperature)
DailyMeanTemperature = tapply(myData$Temperature, myData$Date, FUN=mean)
plot(DailyMeanTemperature, xlab ='Day')
```

# Humidity (X3)

Humidity measured in % at hour of observation.
```{r}
summary(myData$Humidity)
HourlyMeanHumidity = tapply(myData$Humidity, myData$Hour, FUN=mean)
plot(HourlyMeanHumidity, xlab ='Hour')
```

# WindSpeed (X4)

Windspeed measured in metres/second (m/s) at hour of observation. 
```{r}
summary(myData$Windspeed)
hist(myData$Windspeed)
DailyMeanWindspeed = tapply(myData$Windspeed, myData$Date, FUN=mean)
Mean = tapply(myData$Windspeed, myData$Date, FUN=mean)
index = seq(1,353)
fit = lm(Mean~index)
plot(DailyMeanWindspeed, xlab='Day')
abline(fit, col='red')
'Correlation of windspeed against date:'
cor(DailyMeanWindspeed, index)
index2 = seq(0,23)
'Correlation of windspeed against hour:'
cor(HourlyMeanWindspeed, index2)
HourlyMeanWindspeed = tapply(myData$Windspeed, myData$Hour, FUN=mean)
plot(HourlyMeanWindspeed, xlab='Hour')
```

# Visibility (X5)

The distance till which an object or light can be clearly seen, measured in metres (m) at hour of observation.
```{r}
summary(myData$Visibility)
hist(myData$Visibility)
HourlyMeanVisibility = tapply(myData$Visibility, myData$Hour, FUN=mean)
plot(HourlyMeanVisibility, xlab ='Hour')
```

# Solar Radiation (X7)

The amount of solar radiation experienced per square metre, measured in megajoules/metre^2 (Mj/m^2) at hour of observation.
```{r}
summary(myData$SolarRadiation)
myData$Month = format(myData$Date, "%b")
MonthlyMeanSolarRadiation = tapply(myData$SolarRadiation, myData$Month, FUN=mean)
barplot(MonthlyMeanSolarRadiation, ylab='MonthlyMeanSolarRadiation', xlab ='Month')
HourlyMeanSolarRadiation = tapply(myData$SolarRadiation, myData$Hour, FUN=mean)
plot(HourlyMeanSolarRadiation, xlab='Hour')
```

# Rainfall (X8)

The rainfall experienced, measured in millimetres (mm), at hour of observation.
```{r}
summary(myData$Rainfall)
myData$Month = format(myData$Date, "%b")
DailyMaxRF = tapply(myData$Rainfall, myData$Month, FUN=max)
barplot(DailyMaxRF, ylab='MonthlyMaxRainfall', xlab='Month')
```

# Snowfall (X9)

The snowfall experienced, measured in centimetres (cm), at hour of observation.
```{r}
summary(myData$Snowfall)
myData$Month = format(myData$Date, "%b")
DailyMaxSF = tapply(myData$Snowfall, myData$Month, FUN=max)
barplot(DailyMaxSF, ylab='MonthlyMaxSnowfall', xlab='Month')
```

# Seasons (X10: D1, D2, D3)

Categorical variable for current season in Seoul (Winter, Spring, Summer, Autumn) at hour of observation. Base category will be set to Autumn.
```{r}
Seasons = unique(myData$Seasons)
meanBikeRentalPerSeason = rep(0, length(Seasons))
for (idx in seq(length(Seasons))){
  meanBikeRentalPerSeason[idx] = mean(myData[myData$Seasons == Seasons[idx], "RentedBikeCount"])
}
ggplot(data=as.data.frame(meanBikeRentalPerSeason)) +
  geom_col(aes(x=Seasons, y=meanBikeRentalPerSeason, fill=Seasons)) +
  scale_fill_manual(values=c("#003f5c", "#7a5195", "#ef5675", "#ffa600")) +
  labs(x = "Seasons", y = "Mean Rented Bikes Count")
rm(Seasons, meanBikeRentalPerSeason, idx)
```

# Holiday (X11)

Categorical variable for whether or not the day is a holiday. 1 for holiday, 0 for not holiday. Base category will be set to no holiday.
```{r}
matrixOfMeanHrs = matrix(data=NA, nrow=24, ncol=2, dimnames=(list(c(1:24), unique(myData$Holiday))))
for (holidayStatus in colnames(matrixOfMeanHrs)){
  HolidayData = subset(myData[myData$Holiday == holidayStatus, ], select=c("Hour", "RentedBikeCount"))
  for (hour in unique(myData[,"Hour"])){
    matrixOfMeanHrs[hour + 1, holidayStatus] = mean(HolidayData[HolidayData["Hour"] == hour, "RentedBikeCount"])
  }
}
MeanHrs = data.frame(c(1:24), matrixOfMeanHrs[, "Holiday"], matrixOfMeanHrs[, "No Holiday"])
colnames(MeanHrs) = c("Hours", "Holiday", "NoHoliday")
ggplot(MeanHrs, aes(x=Hours - 1)) + 
  labs(x = "Hours", y = "Mean Rented Bikes Count", color="") +
  geom_line(aes(y=Holiday, color="Holiday")) + 
  geom_line(aes(y=NoHoliday, color="No Holiday"))
rm(matrixOfMeanHrs, holidayStatus, HolidayData, hour, MeanHrs)
```

# Weekend (weekends)

Categorical variable for whether or not the day is a weekend. 1 for weekend, 0 for not weekend. Base category will be set to not weekend.
```{r}
myData$WeekDay = format(myData$Date, "%a")
matrixOfMeanHrs = matrix(data=NA, nrow=24, ncol=7, dimnames=(list(c(1:24),unique(myData$WeekDay))))
for (weekday in colnames(matrixOfMeanHrs)){
  weekdayData = subset(myData[myData$WeekDay == weekday, ], select=c("Hour", "RentedBikeCount"))
  for (hour in unique(myData[,"Hour"])){
    matrixOfMeanHrs[hour + 1, weekday] = mean(weekdayData[weekdayData["Hour"] == hour, "RentedBikeCount"])
  }
}
MeanHrs = data.frame(c(1:24), matrixOfMeanHrs[, "Mon"], 
                              matrixOfMeanHrs[, "Tue"],
                              matrixOfMeanHrs[, "Wed"],
                              matrixOfMeanHrs[, "Thu"],
                              matrixOfMeanHrs[, "Fri"],
                              matrixOfMeanHrs[, "Sat"],
                              matrixOfMeanHrs[, "Sun"])
colnames(MeanHrs) = c("Hours", "Monday", "Tuesday", "Wednesday", "Thursday", 
                      "Friday", "Saturday", "Sunday")
ggplot(MeanHrs, aes(x=Hours - 1)) + 
  geom_line(aes(y=Monday, color="Monday")) + 
  geom_line(aes(y=Tuesday, color="Tuesday")) + 
  geom_line(aes(y=Wednesday, color="Wenesday")) +
  geom_line(aes(y=Thursday, color="Thursday")) + 
  geom_line(aes(y=Friday, color="Friday")) + 
  geom_line(aes(y=Saturday, color="Saturday")) +
  geom_line(aes(y=Sunday, color="Sunday")) + 
  scale_color_manual(values=c("#003f5c", "#374c80", "#7a5195", "#bc5090", 
                              "#ef5675", "#ff764a", "#ffa600")) +
  labs(x = "Hours", y = "Mean Rented Bikes Count", color='Day of Week')
rm(matrixOfMeanHrs, weekday, weekdayData, hour, MeanHrs)
```


# Months (m1-m11)

Categorical variable for which month it is. Base category will be set to december.
```{r}
myData$Month = format(myData$Date, "%b")
Months = factor(unique(myData$Month), levels = month.abb)
meanBikeRentalPerMonth = rep(0, length(Months))
for (idx in seq(length(Months))){
  meanBikeRentalPerMonth[idx] = mean(myData[myData$Month == Months[idx], "RentedBikeCount"])
}
ggplot(data=as.data.frame(meanBikeRentalPerMonth)) +
  geom_col(aes(x=Months, y=meanBikeRentalPerMonth, fill=Months)) +
  labs(x = "Months", y = "Mean Rented Bikes Count")
rm(Months, meanBikeRentalPerMonth, idx)
```

\newpage

\textbf{Removed Variables}

FunctioningDay and DewPointTemp will not be considered in the model.

# FunctioningDay (X12)

Categorical variable. 1 if bikes are funcitoning, 0 if not.
Days when bikes are not functional will be guaranteed to produce observations of 0 bikes rented per hour. Therefore, there is no need to include this variable in our model.

# DewPointTemp (X6)

The temperature at dew point measured in celsius (°C) at hour of observation.
Due to a high correlation between DewPointTemp and Temperature it is redundant to include both DewPointTemp and Temeprature in the model.
```{r}
cor(myData$Temperature, myData$DewPointTemp)
```

\newpage

\textbf{\LARGE Bibliography}
